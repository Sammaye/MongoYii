{"name":"Mongoyii","tagline":"A Yii MongoDB ORM","body":"# MongoYii\r\n\r\nAnother active record handler for the Yii framework that supports MongoDB.\r\n\r\n## Rationale\r\n\r\nThere is already a great extension called YiiMongoDBSuite out for Yii so why make another? YiiMongoDBSuite has certain flaws which I wish to address:\r\n\r\n- Does not support `$or` natively\r\n- Very large and complicated code base\r\n- Does not support the later versions of the PHP driver (1.3.x series) that well\r\n- Obscured the MongoDB query language, layering a query language over the top\r\n\r\nAfter some spare time I decided that I would take the liberty to make a MongoDB extension for Yii. It is really basically a \"glue\" between MongoDB and\r\nYii and it is designed to be quite free form in that respect.\r\n\r\nThere are a few points of design I wished to enforce:\r\n\r\n- expose the MongoDB query language in its raw form\r\n- make the programming of this extension simple and easy to maintain for all parties\r\n- make sure this extension worked with both the new and old versions of the MongoDB driver\r\n- attempt to make things a little more performant\r\n- try to follow Yiis own CActiveRecord API as much as possible without compromising MongoDB \"semantics\" such as the name for query operators and the use of a `MongoCursor`\r\n\r\nOk so we have got some of the rationale in place it is time to actually talk about the extension.\r\n\r\n## Setting up the extension\r\n\r\nIn order to use the extension you first need to set it up. The first thing to do is to download the source code and place it somewhere accessible within your applications structure, I have chosen\r\n`protected/extensions/MongoYii`.\r\n\r\nOnce you have the source code in place you need to edit your `main.php` configuration file (`console.php` will need modifying too if you intend to use this extension in the console) with\r\nthe following type of configuration:\r\n\r\n\t'mongodb' => array(\r\n\t\t'class' => 'EMongoClient',\r\n\t\t'server' => 'mongodb://localhost:27017',\r\n\t\t'db' => 'super_test'\r\n\t),\r\n\r\nAnd add the MongoYii directories to your `import` section:\r\n\r\n\t'application.extensions.MongoYii.*',\r\n\t'application.extensions.MongoYii.validators.*',\r\n\t'application.extensions.MongoYii.behaviors.*'\r\n\r\nThat is the basic setup of the extension.\r\n\r\nYou will notice that I use a `EMongoClient`. This is a bit deceptive since it actually represents `MongoClient` and `MongoDB` combined.  This means that whenever you call the magic `__call`\r\non the `EMongoClient` like so:\r\n\r\n\tYii::app()->mongodb->getSomething();\r\n\r\nIt will either try and call a function of `getSomething` in `EMongoClient` or, if the function does not exist, try and call it within the `MongoDB` class.\r\n\r\nIf you wish to call a function on the `MongoClient` or `Mongo` class you will need to retrieve the connection object like so:\r\n\r\n\tYii::app()->mongodb->getConnection()->getSomething();\r\n\r\n`EMongoClient` is also designed to handle full write concern and read preferences in a compatible manner with all versions of the driver.\r\n\r\n**Note:** The models will by default seek a `mongodb` component within your configuration so please make sure that unless you modify the extension, or use it without active record, to\r\nmake your default (master) connection be a component called `mongodb`.\r\n\r\n### Write Concern (formally \"safe\" writes)\r\n\r\nThis extension uses the new `w` variable globally to handle the level of write concern you wish to impose on MongoDB.\r\n\r\nBy default the extension will assume acknowledged writes, this means `safe=true` or `w=1` depending on the version of your driver. To change this simply add `w` to your `mongodb` components configuration\r\nand give it a value according to the [PHP documentation](http://php.net/manual/en/mongo.writeconcerns.php).\r\n\r\nFor those using the 1.3.x series of the driver there is also a `j` option which can be set to either `true` or `false` within the configuration which allows you to control\r\nwhether or not the write is journal acknowledged.\r\n\r\n**Note:** Write Concern is abstracted from the driver itself to make this variable compatible across all versions of the driver so please use the configuration or the `EMongoClient` `w` and\r\n`j` class variables to set the write concern when you need to, otherwise that write concern will not be used within active record.\r\n\r\n**Note:** Write Concern works differently when you touch the database directly and the write concern issued within the `EMongoCLient` class will have no\r\neffect. Instead you should always ensure in this case you specify the write concern manually according to your driver version.\r\n\r\nThis may change in the future but at the moment when you want the active record to go away it just will.\r\n\r\n### Read Preference\r\n\r\nFor those using the old driver there is only one extra configuration variable available to you, `setSlaveOkay`. Set this to either `true` or `false` in your configuration to make it\r\npossible to read from members of a replica set.\r\n\r\nFor those using the 1.3.x series of the driver you have the `RP` configuration variable. The RP configuration variable is a 1-1 relation to the options of `setReadPreference`\r\non the `MongoClient` class with one exception. The first parameter is not a constant but instead the name of the constant. An example of using read preferences in your configuration\r\nwould be:\r\n\r\n\t'RP' => array('RP_SECONDARY' /* The name of the constant from the documentation */,\r\n\t\tarray(/* Would normally be read tags, if any */))\r\n\r\nPlease refer to the [drivers documentation for a full set of options here](http://php.net/manual/en/mongo.readpreferences.php).\r\n\r\nTo change the Read Preference at any time please use the function applicable to your driver; for 1.3.x series:\r\n\r\n\tYii::app()->mongodb->setReadPreference(MongoClient::RP_PRIMARY, array());\r\n\r\nand for pre-1.3:\r\n\r\n\tYii::app()->mongodb->setSlaveOkay(true);\r\n\r\n**Note:** Unlike write concern, the `RP` and `setSlaveOkay` variables do not inter-lock between different versions of the driver, using the `EMongoClient` `RP` variable\r\nwill not translate to `slaveOkay`.\r\n\r\n## Using MongoDB without Active Record\r\n\r\nYou can call the database directly at any time using the same implemented methods as you would using the driver normally. As an example, to query the database:\r\n\r\n\tYii::app()->mongodb->collection->find(array('name' => 'sammaye'));\r\n\r\nSo the active record element of MongoYii can quickly disappear if needed.\r\n\r\n## EMongoModel\r\n\r\nThe `EMongoModel` is a stripped down version of the `EMongoDocument`.\r\n\r\nThis was made separate from `EMongoDocument` to provide a small and slim active model for use on subdocuments. Whenever you make a class based subdocument you can extend this class.\r\n\r\nThe `EMongoModel` implements all that `CModel` does but with a few added and changed features.\r\n\r\n### Magic functions\r\n\r\n#### This has been changed\r\n\r\nChanged as of this issue: [https://github.com/Sammaye/MongoYii/issues/7](https://github.com/Sammaye/MongoYii/issues/7) whereby\r\n[@f10i](https://github.com/f10i) gives over a pull request that can actually fix the schemaless issue completely.\r\n\r\nThe `__get` and `__set` have been completely re-written around his ideas and should now have all the same power as Yiis own `CActiveRecord` class.\r\n\r\nThe below is still shown as a note to people who use old checkouts:\r\n\r\nIn order to support the schema-less nature of MongoDB without using hacks like behaviours I have changed the way that the magic functions in Yii work slightly.\r\nThe `__set` and `__get` will no longer seek out behaviour properties or call variable function events.\r\n\r\nBehaviours tend to manipulate a `owner` within its own self contained context while allowing the calling of events from the magic functions is role blurring. Events should be\r\ncalled as functions if you want to use them. In my opinion the `__set` and `__get` functions have been made clearer by this.\r\n\r\n### Virtual Attributes\r\n\r\nThis extension supports virtual attributes via a doc block notation syntax of `@virtual`, for example:\r\n\r\n\tclass User extends EMongoModel{\r\n\t    /** @virtual */\r\n\t    public $somevar;\r\n\t}\r\n\r\nThese variables can be used in the same way as everything else except they will never be saved in MongoDB.\r\n\r\n**Note:** due to how PHP OO accession works it is a good idea to make all your record fields, virtual or not, `public`.\r\n\r\n### Relations\r\n\r\nUnlike in SQL where you have many complicated types of relations, in MongoDB you tend to only have two:- `one` and `many`.\r\n\r\nAs you have guessed, you can only define two types of relation in this extension - `one` and `many`. Lets take a look at an example:\r\n\r\n\tfunction relations(){\r\n\t\treturn array(\r\n\t\t\t'others' => array('many', 'Other', 'otherId')\r\n\t\t);\r\n\t}\r\n\r\nYou will recognise a lot of this from Yiis own active record, in fact a lot is the same. We define a name for the relation as a key and then we define either `one` or `many` in text\r\n(constants seemed useless with only two types) and then we define a class name, `Other` in this case, and then we define the foreign key in that class, `otherId`.\r\n\r\nThe default behaviour of relations is to attempt to use the primary key, `_id`, of the current model to query the foreign key. This is a problem for `EMongoModel`\r\nsince it has no primary key. Make sure that if you use this in `EMongoModel` you define a `on` clause to replace the primary key of the current model.\r\n\r\nThe `on` clause supports multiple field types. It can take a `DBRef` or an `ObjectId` or an array of `ObjectId`s depending on how you define your document.\r\n\r\nYou can also, just like in Yii, define a `where` clause. This is a 1-1 relation to the syntax used within normal querying in MongoDB and the extension will basically merge this\r\nclause with the primary key field you define in order to query for the relation.\r\n\r\nAll relations are returned as `EMongoCursor`s which is basically the Yii active record implementation of `MongoCursor`. There is no eager loading, if you wish to use eager loading\r\nplease look into using `iterator_to_array()` on the return value from calling the relation.\r\n\r\n### getDocument()\r\n\r\nJust gets the docuemnt \"as-it-is\". This means that if you put meta objects in like nested `EMongoModel`s it will get these back in the output.\r\n\r\n### getRawDocument()\r\n\r\nWill strip away all classes used by the extension and return a document suitable for use with MongoDB.\r\n\r\n### getJSONDocument()\r\n\r\nWill run `getRawDocument()` and then return its output as a JSON string.\r\n\r\n### getBSONDocument()\r\n\r\nWill run `getRawDocument()` and then return its output as a BSON string.\r\n\r\n## EMongoDocument\r\n\r\nThe `EMongoDocument` extends `EMongoModel` and implements all of its features along with the needed features for database accession. It also implements as much as possible of\r\n`CActiveRecord`.\r\n\r\n**Note:** The functions that allow database usage are not defined within this section of the documentation. Instead those functions are actually defined within the \"Querying\" section of this\r\ndocumentation. Please move to the \"Querying\" section if you wish to read about this part of the `EMongoDocument`.\r\n\r\n### collectionName()\r\n\r\nReturns a string representing the collection name. All active record models should implement this function although it is not `abstract`.\r\n\r\n### primaryKey()\r\n\r\nCurrently only returns `_id` as the key. This function is `private` and cannot be overridden.\r\n\r\nIf you are using a primary key that IS NOT a `ObjectId` (otherwise known as a `MongoId` in the PHP driver) then you should override the `getMongoId` function of the `EMongoDocument`\r\nto not return a `MongoId`:\r\n\r\n\tpublic function getMongoId($value){\r\n\t\treturn $value;\r\n\t}\r\n\r\nYou can, of course, add whatever procedure or formatting code you need within this function to make sure that your primary key is ready for MongoDB when it comes to querying.\r\n\r\n### Scopes\r\n\r\nScopes are fully supported in all the normal ways as with `CActiveRecord` but with one difference; the terminology.\r\n\r\nThe scopes, and queries, in this extension use these words to describe their parts:\r\n\r\n- `condition` to describe the condition itself\r\n- `sort` to describe the sort\r\n- `skip` to describe offset\r\n- `limit` to describe limit\r\n\r\nAs an example of a full default scope which omits deleted models to get the latest 10 skipping the first one:\r\n\r\n\tarray(\r\n\t\t'condition' => array('deleted' => array('$ne' => 1)),\r\n\t\t'sort' => array('date' => -1),\r\n\t\t'skip' => 1,\r\n\t\t'limit' => 11\r\n\t)\r\n\r\nYou can also define your own scopes, however, it is a little different to how you are used to doing it in Yii:\r\n\r\n\tfunction someScope(){\r\n\t\t$this->mergeDbCriteria(array(\r\n\t\t\t'condition'=>array('scoped' => true),\r\n\t\t\t'sort'=>array('date'=>-1),\r\n\t\t\t'skip'=>1,\r\n\t\t\t'limit'=>11\r\n\t\t));\r\n\t}\r\n\r\nAs you will notice the `_certeria` variable within the EMongoDocument which would normally be a `EMongoCriteria` object is actually completely array based.\r\n\r\nThis applies to all scope actions; they are all array based.\r\n\r\nTo help you in not having the `EMongoCriteria` object the `EMongoDocument` provides a helper function for merging criteria objects called `mergeCriteria`. Using this function will\r\nhave no impact on the model itself and merely merges criteria to be returned. As an example of using the `mergeCriteria` function:\r\n\r\n\tfunction someScope(){\r\n\r\n\t\t$criteria = array(\r\n\t\t\t'condition'=>array('scoped' => true),\r\n\t\t\t'sort'=>array('date'=>-1),\r\n\t\t\t'skip'=>1,\r\n\t\t\t'limit'=>11\r\n\t\t);\r\n\r\n\t\tif($this->deleted)\r\n\t\t\t$criteria = $this->mergeCriteria($criteria,array('condition'=>array('deleted'=>1)));\r\n\r\n\t\t$this->mergeDbCriteria($criteria);\r\n\t\treutrn $this;\r\n\t}\r\n\r\n**Note:** Just like in Yii, normally scopes are not reset automatically, please use `resetScope()` to reset the scope.\r\n\r\n### equals()\r\n\r\nChecks if the current model equals another sent in as a parameter.\r\n\r\n### exists()\r\n\r\nChecks if a document exists in the database with the criteria supplied as the first parameter.\r\n\r\n### clean()\r\n\r\nCleans the document of all properties and relations.\r\n\r\n### refresh()\r\n\r\nRuns `clean()` and then re-populates the model from the database.\r\n\r\n### getCollection()\r\n\r\nReturns the raw `MongoCollection`.\r\n\r\nIt is normally best not to use this and instead to use the extension wrapped editions - `updateAll` and `deleteAll`. The only difference of said functions\r\nfrom doing it manually on `getCollection()` is that the functions understand the write concern of the extension.\r\n\r\n### Example\r\n\r\nSo now that we have discussed the `EMongoDocument` lets look at the most base of example:\r\n\r\n\tclass User extends EMongoDocument{\r\n\t\tfunction collectionName(){\r\n\t\t\treturn 'users';\r\n\t\t}\r\n\r\n\t\tpublic static function model($className=__CLASS__){\r\n\t\t\treturn parent::model($className);\r\n\t\t}\r\n\t}\r\n\r\nThis is the most basic document that can exist - no predefined schema and only a `model` function (same as Yii active record) and the `tableName`, otherwise known as the `collectionName`,\r\nare needed.\r\n\r\nAs time goes on you will want to add certain fields like virtual attributes and such to make your life easier:\r\n\r\n\tclass User extends EMongoDocument{\r\n\r\n\t\t/** @virtual */\r\n\t\tpublic $agree = 1;\r\n\r\n\t\tpublic $addresses = array();\r\n\r\n\t\tfunction collectionName(){\r\n\t\t\treturn 'users';\r\n\t\t}\r\n\r\n\t\tpublic static function model($className=__CLASS__){\r\n\t\t\treturn parent::model($className);\r\n\t\t}\r\n\t}\r\n\r\nNotice how I have added the `addresses` field despite not needing to? I do this due to the way that PHP uses magic functions.\r\n\r\nIf you access an array magically you cannot, in the same breath, manipulate it since it is an indirect accession of the variable. So a good tip here: if you plan on having subdocuments\r\nin your document it might be good to explicitly declare the field as a variable within the class.\r\n\r\n## Querying\r\n\r\nQuerying attempts to expose the native MongoDB querying language as much as possible. A `EMongoCriteria` class is provided, however, it is not required and does not provide any more functionality\r\nthan just doing it via arrays. The `EMongoCriteria` class is not relied on anywhere and is not needed.\r\n\r\n### find()\r\n\r\n`find()` is really simple. It is essentially a 1-1 to the drivers own `find()` function and implements the same specifics. Just like the drivers edition, it also returns a cursor\r\ninstance (`EMongoCursor`) which can be used to lazy load results from the database.\r\n\r\nIt will return a cursor irrespective of whether it finds results or not. However if it cannot find results then `count` will return `0` and the iterator will not have any iterations\r\nto it.\r\n\r\n**Note:** The cursor does not eager load documents, instead if you wish to accomplish this please wrap the call to `find` in a `iterator_to_array` function.\r\n\r\n### findOne() and findBy_id()\r\n\r\n`findOne`, just like `findBy_id` is a straight 1-1 implementation of the drivers own `findOne` method and returns an active record record model if something was found, otherwise `null`.\r\n\r\nThe `findBy_id` function takes either a hexadecimal representation of a `ObjectId` in string form or wrapped in the `MongoId` class and will seek out a record with that `_id` using\r\nthe `findOne` function, returning the exact same. It is basically a helper for `findOne` to make your life a little easier.\r\n\r\n### Scopes\r\n\r\nThe read functions of this extension have full support for scopes within models.\r\n\r\n### Example\r\n\r\nOk so now we have a basic grasp of querying lets look at an example:\r\n\r\n\t$c = User::model()->recently()->find(array('deleted' => 0))->sort(array('joined' => -1))->skip(2)->limit(3);\r\n\r\nThis may look complicated but I will now break it down for you:\r\n\r\n- `User::model()` gets our model\r\n- `->recently()` is actually a scope, this is not needed but good for demonstration purposes\r\n- `->find(/*...*/)` is basically the MongoDB drivers `find` method and returns a `EMongoCursor` which implements a `MongoCursor`\r\n- `->sort()` is basically the MongoDB drivers `sort` method on the `MongoCursor`\r\n- `->limit()` is, again, basically the MongoDB drivers own `limit` function on the `MongoCursor`\r\n\r\nFor a reference on what operators are supported please refer to the MongoDB documentation: [http://docs.mongodb.org/manual/reference/operators/](http://docs.mongodb.org/manual/reference/operators/)\r\n\r\n**Note:** Other functions like `findByAttributes` have been omitted since it seems pointless with MongoDBs querying language to implement those.\r\n\r\n### save()\r\n\r\nThis `save`s the document and is used externally as a means to access either `insert` or `update` on the active record model, i.e.:\r\n\r\n\tif($user->validate()) $user->save();\r\n\r\nIf the document is new it will insert otherwise it will update.\r\n\r\n### insert()\r\n\r\nThis is used internally by the active record model. If the record is new it will attempt to insert it instead of updating it otherwise it will throw\r\nan error.\r\n\r\n### update()\r\n\r\nThis is used internally by the active record model. If the record is not new it will attempt to update it otherwise it will throw an error.\r\n\r\nIf you send in attributes into either this function or the `save` function it will attempt to do a `$set` on those attributes otherwise it will `save` the model.\r\n\r\n### delete()\r\n\r\nThis is used to delete the current active record.\r\n\r\n### deleteByPk() and updateByPk()\r\n\r\nThese are helpers to the update and delete functions except they act on the database directly, instead of through active record.\r\n\r\nTo show by example:\r\n\r\n\tUser::model()->deleteByPk($_id[, array('deleted' => 1)[, array('w' => 2)]]);\r\n\tUser::model()->updateByPk($_id, array('$set' => array('d' => 1)[, array('deleted' => 1)[, array('w' => 2)]]);\r\n\r\nArguments shown in `[]` are optional.\r\n\r\nThese functions can take both a string and a `MongoId` as the `$_id` parameter.\r\n\r\n### updateAll() and deleteAll()\r\n\r\nSame as above really except these translate directly to the MongoDB drivers own `update` and `delete` functions.\r\n\r\n**Note:** `UpdateAll` is `multi` `true` by default\r\n\r\n## Validation\r\n\r\nThe validation has pretty much not changed except for one validator which required some rewriting, the unique validator.\r\n\r\nBasically the `CUniqueValidator` has been retro-fitted to work for MongoDB so the call to the validator is the same but you must take into account that the name of the\r\nvalidator is now `EMongoUniqueValidator`.\r\n\r\n## Subdocuments\r\n\r\nSubdocuments are, mostly, not automatically supported by this extension. There a couple of reasons, firstly due to performance - automating subdocument usage requires a lot of\r\nloaded classes to handle different subdocuments and their validation.\r\n\r\nThe other main reason is that, in any project I have done, whenever I tried to automate subdocuments through active record it has always resulted in me actually ditching\r\nit and doing the process manually. It has been proven many times that you rarely actually want automated subdocuments and normally you want greater control over their storage than\r\nthis extension could provide.\r\n\r\nSo that is a brief understanding of the rationale behind the idea to ditch automatic subdocument handling within the active record.\r\n\r\nThis does not mean you cannot embed subdocument classes at all; when saving, the active record will iterate the document and attempt to strip any `EMongoModel` or `EMongoDocument`\r\nclasses that have sprung up.\r\n\r\nThis all aside, there is a subdocument validator and technically it can even accept multi-level nesting. Please bare in mind, though, that it will cause repitition\r\nfor every level you use it on. This WILL have a performance implication on your application.\r\n\r\nAn example of using an array based subdocument is:\r\n\r\n\tfunction rules(){\r\n\t\treturn array(\r\n\t\t\tarray('addresses', 'subdocument', 'type' => 'many', 'rules' => array(\r\n\t\t\t\tarray('road,town,county,post_code', 'safe'),\r\n\t\t\t\tarray('telephone', 'integer')\r\n\t\t\t)),\r\n\t\t);\r\n\t}\r\n\r\nWhile an example of a class based one is:\r\n\r\n\tfunction rules(){\r\n\t\treturn array(\r\n\t\t\tarray('addresses', 'subdocument', 'type' => 'many', 'class' => 'Other'),\r\n\t\t);\r\n\t}\r\n\r\n`type` defines the type of subdocument, as with relations this is either `one` or `many`.\r\n\r\nThe validator will evaluate the rules as though they are completely separate from the originating model so in theory there is nothing stopping you from using any validator you want.\r\n\r\nThe error output for the validator will differ between the `one` and `many` types of subdocument. With `one` the validator will output the model errors directly onto the field\r\nhowever with `many` it will create a new element for each model (row) with embedded errors in that new element in the field on the parent, for example:\r\n\r\n\tarray(\r\n\t\t'addresses' => array(\r\n\t\t\t0 => array(\r\n\t\t\t\t'telephone' => array(\r\n\t\t\t\t\t0 => 'Some error here'\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t)\r\n\t)\r\n\r\n**Note:** While on the subject, to avoid the iteration every time you save the root document (since validation is run by default in Yii on save) you should confine your subdocument\r\nvalidators to specific scenarios where they will be actively used.\r\n\r\n## Using the ActiveDataProvider\r\n\r\nThis extension comes with a `CActiveDataProvider` helper called `EMongoDataProvider`. It works exactly the same way except for how it is called.\r\n\r\nInstead of using a `EMongoCriteria` or something similar you use arrays like so:\r\n\r\n\tnew EMongoDataProvider(array(\r\n\t\t'criteria' => array(\r\n\t\t\t'condition' => array(),\r\n\t\t\t'sort' => array(),\r\n\t\t\t'skip' => 1,\r\n\t\t\t'limit' => 1\r\n\t\t),\r\n\t\t/* All other options */\r\n\t));\r\n\r\nThe `criteria` option basically relates to the parts of a cursor.\r\n\r\nThis extension does fully support `CGridView` (thanks to @acardinale for the fix) and it should also be able to take the `CListView` as well.\r\n\r\nAs a side note to the above, `CGridView` is best used when you predefine the schema you wish to display within the definition of the `CGridView` widget. So, to display an example\r\nfor a user model:\r\n\r\n\t$this->widget('zii.widgets.grid.CGridView', array(\r\n\t\t'id'=>'user-grid',\r\n\t\t'dataProvider'=>$model->search(),\r\n\t\t'filter'=>$model,\r\n\t\t'columns'=>array(\r\n\t\t\t'_id',\r\n\t\t\t'username',\r\n\t\t\t'addresses',\r\n\t\t\t'create_time',\r\n\t\t\tarray(\r\n\t\t\t\t'class'=>'CButtonColumn',\r\n\t\t\t\t'template'=>'{update}{delete}',\r\n\t\t\t),\r\n\t\t),\r\n\t));\r\n\r\nThis is normally the best method because, of course, MongoDB is schemaless (has a flexible schema is more appropriate) so sometimes it doesn't work so well in a rigid table.\r\n\r\n## Known Flaws\r\n\r\n- Covered queries are not supported, but then as I am unsure if they really fit with active record\r\n- Subdocuments are not automated, however, I have stated why above\r\n- the aggregation framework does not fit well with active record as such it is not directly supported within the models\r\n\r\nI am sure there are more but that is the immediate flaws you need to consider in this extension.\r\n\r\n## Bugs\r\n\r\nProbably some, however, I will endeavour to accept pull requests and fix reported bugs.\r\n\r\n## Examples\r\n\r\nPlease look to the tests folder for further examples of how to use this extension, it is quite comprehensive.\r\n\r\n## Running the Tests\r\n\r\nThe tests require the PHPUnit plugin with all dependencies compiled. Using PEAR you can initiate the following command:\r\n\r\n\tsudo pear install --force --alldeps phpunit/PHPUnit &&\r\n\tpear install phpunit/dbUnit &&\r\n\tpear install phpunit/PHPUnit_Story &&\r\n\tpear install phpunit/PHPUnit_Selenium\r\n\r\nAfter that you can just tell PHPUnit to run all tests within the `tests/` folder with no real order.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}